<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"aliuhongliang.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本文主要介绍 多线程。">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程">
<meta property="og:url" content="https://aliuhongliang.github.io/2025/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="LiuHongLiang">
<meta property="og:description" content="本文主要介绍 多线程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aliuhongliang.github.io/images/xiancheng_op_log_01.png">
<meta property="og:image" content="https://aliuhongliang.github.io/images/gcd_op_yilai_log.png/">
<meta property="article:published_time" content="2025-01-10T18:02:37.000Z">
<meta property="article:modified_time" content="2025-09-05T08:00:40.122Z">
<meta property="article:author" content="刘宏亮">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aliuhongliang.github.io/images/xiancheng_op_log_01.png">

<link rel="canonical" href="https://aliuhongliang.github.io/2025/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>多线程 | LiuHongLiang</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LiuHongLiang</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://aliuhongliang.github.io/2025/01/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="刘宏亮">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuHongLiang">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          多线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-10 18:02:37" itemprop="dateCreated datePublished" datetime="2025-01-10T18:02:37+00:00">2025-01-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-05 08:00:40" itemprop="dateModified" datetime="2025-09-05T08:00:40+00:00">2025-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          
            <div class="post-description">本文主要介绍 多线程。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>正在运行的程序被称为进程</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是进程中最小的执行单元，一个进程可以有多条线程，但是至少包含一条线程，被称为主线程  </p>
<ol>
<li>多线程的优点：</li>
</ol>
<ul>
<li>提高程序的执行效率</li>
<li>提高资源的利用率</li>
</ul>
<ol start="2">
<li>多线程的缺点：</li>
</ol>
<ul>
<li>占用一定的内存空间</li>
<li>线程越多，CPU在调度线程上的开销就越大</li>
<li>线程越多，程序设计就越复杂，比如线程之间的通信，多线程的数据共享，需要考虑数据安全问题</li>
</ul>
<h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><p>程序启动的同时会开启一个线程就是主线程，主要用来处理UI，所有更新UI的操作都必须在主线程上执行。不要把耗时操作放在主线程。</p>
<h3 id="子线程"><a href="#子线程" class="headerlink" title="子线程"></a>子线程</h3><p>执行耗时操作，比如：网络请求，数据处理，文件IO，图片处理，数据库访问等，保证主线程的流程。</p>
<h3 id="并发队列、串行队列-、同步、异步"><a href="#并发队列、串行队列-、同步、异步" class="headerlink" title="并发队列、串行队列 、同步、异步"></a>并发队列、串行队列 、同步、异步</h3><p>同步异步：表示是否开启新线程。<br>串行并发：表示该线程中，如何执行任务</p>
<p>同步：不开辟线程，在当前线程中执行任务。可能是主线程，也可能是子线程<br>异步：开辟新线程。<br>串行队列：同一时间只执行一个任务。<br>并发队列：同时允许多个任务同时执行</p>
<table>
<thead>
<tr>
<th>任务</th>
<th>并发队列</th>
<th>串行队列</th>
<th>主队列</th>
</tr>
</thead>
<tbody><tr>
<td>同步</td>
<td>不开启新线程<br/>串行执行</td>
<td>不开启新线程<br/>串行执行</td>
<td>死锁</td>
</tr>
<tr>
<td>异步</td>
<td>开启新线程<br/>并发执行</td>
<td>有开启新线程<br/>串行执行</td>
<td>不开启新线程<br/>串行执行</td>
</tr>
</tbody></table>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取主队列</span></span><br><span class="line">dispatch_queue_t mainQueue <span class="operator">=</span> dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取全局并发队列</span></span><br><span class="line">dispatch_queue_t queue <span class="operator">=</span> dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建串行队列</span></span><br><span class="line">dispatch_queue_t queue <span class="operator">=</span> dispatch_queue_create(<span class="string">&quot;queue&quot;</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并行队列</span></span><br><span class="line">dispatch_queue_t queue <span class="operator">=</span> dispatch_queue_create(<span class="string">&quot;queue&quot;</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">并发 <span class="operator">+</span> 同步(sync)</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)syncConcurrent &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;currentThread---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：syncConcurrent---Begin&quot;</span>);</span><br><span class="line">    <span class="comment">//创建并行队列</span></span><br><span class="line">    dispatch_queue_t queue <span class="operator">=</span> dispatch_queue_create(<span class="string">&quot;queue&quot;</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>);</span><br><span class="line">    dispatch_sync(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务1</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：1---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务2</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：2---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务3</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：3---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：syncConcurrent---End&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>currentThread—&lt;_NSMainThread: 0x600003e64040&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：syncConcurrent—Begin<br>wuwuFQ：1—&lt;_NSMainThread: 0x600003e64040&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：1—&lt;_NSMainThread: 0x600003e64040&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：2—&lt;_NSMainThread: 0x600003e64040&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：2—&lt;_NSMainThread: 0x600003e64040&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：3—&lt;_NSMainThread: 0x600003e64040&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：3—&lt;_NSMainThread: 0x600003e64040&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：syncConcurrent—End</p>
</blockquote>
<blockquote>
<p>同步（sync）会阻塞线程等待block回调，并且是不具备开启线程能力的，即使放在并发队列里面，还是需要当前线程也就是主线程去执行任务的<br>所以结论是：并发+同步 &#x3D; 没有开启新线程，串行执行任务</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">并发 <span class="operator">+</span> 异步(<span class="keyword">async</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)asyncConcurrent &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;currentThread---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：asyncConcurrent---Begin&quot;</span>);</span><br><span class="line">    <span class="comment">//创建并行队列</span></span><br><span class="line">    dispatch_queue_t queue <span class="operator">=</span> dispatch_queue_create(<span class="string">&quot;queue&quot;</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>);</span><br><span class="line">    dispatch_async(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务1</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：1---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务2</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：2---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务3</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：3---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：asyncConcurrent---End&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>currentThread—&lt;_NSMainThread: 0x6000033841c0&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：asyncConcurrent—Begin<br>wuwuFQ：2—&lt;NSThread: 0x6000033c4240&gt;{number &#x3D; 6, name &#x3D; (null)}<br>wuwuFQ：3—&lt;NSThread: 0x6000033c4a00&gt;{number &#x3D; 3, name &#x3D; (null)}<br>wuwuFQ：1—&lt;NSThread: 0x600003396880&gt;{number &#x3D; 7, name &#x3D; (null)}<br>wuwuFQ：asyncConcurrent—End<br>wuwuFQ：2—&lt;NSThread: 0x6000033c4240&gt;{number &#x3D; 6, name &#x3D; (null)}<br>wuwuFQ：3—&lt;NSThread: 0x6000033c4a00&gt;{number &#x3D; 3, name &#x3D; (null)}<br>wuwuFQ：1—&lt;NSThread: 0x600003396880&gt;{number &#x3D; 7, name &#x3D; (null)}    </p>
</blockquote>
<blockquote>
<p>这个组合是我们开发过程中经常使用的，异步(async)开启了新线程，并行队列不会阻塞线程，不会等待block的回调，CPU在几个线程之间快速切换，我运行了多次，每次的执行顺序都不通。<br>所以结论是：并发+异步 &#x3D; 开启了新线程，并发执行任务</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">串行 <span class="operator">+</span> 同步(sync)</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)syncSerial &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;currentThread---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：syncSerial---Begin&quot;</span>);</span><br><span class="line">    <span class="comment">//创建串行队列</span></span><br><span class="line">    dispatch_queue_t queue <span class="operator">=</span> dispatch_queue_create(<span class="string">&quot;queue&quot;</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>);</span><br><span class="line">    dispatch_sync(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务1</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：1---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务2</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：2---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_sync(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务3</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：3---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//        任务4</span></span><br><span class="line">	<span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123; </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：4---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：syncSerial---End&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>currentThread—&lt;_NSMainThread: 0x6000026f4000&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：syncSerial—Begin<br>wuwuFQ：1—&lt;_NSMainThread: 0x6000026f4000&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：1—&lt;_NSMainThread: 0x6000026f4000&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：2—&lt;_NSMainThread: 0x6000026f4000&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：2—&lt;_NSMainThread: 0x6000026f4000&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：3—&lt;_NSMainThread: 0x6000026f4000&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：3—&lt;_NSMainThread: 0x6000026f4000&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：4—&lt;_NSMainThread: 0x6000026f4000&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：4—&lt;_NSMainThread: 0x6000026f4000&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：syncSerial—End  </p>
</blockquote>
<blockquote>
<p>同步不具备开启新线程能力，任务都在主线程按序执行<br>所以结论是：串行+同步 &#x3D; 没有开启新线程，串行执行任务</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">串行 <span class="operator">+</span> 异步(<span class="keyword">async</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)asyncSerial &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;currentThread---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：asyncSerial---Begin&quot;</span>);</span><br><span class="line">    <span class="comment">//创建串行队列</span></span><br><span class="line">    dispatch_queue_t queue <span class="operator">=</span> dispatch_queue_create(<span class="string">&quot;queue&quot;</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>);</span><br><span class="line">    dispatch_async(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务1</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：1---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务2</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：2---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务3</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：3---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//        任务4</span></span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：4---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：asyncSerial---End&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>currentThread—&lt;_NSMainThread: 0x600002f6c400&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：asyncSerial—Begin<br>wuwuFQ：1—&lt;NSThread: 0x600002f2c3c0&gt;{number &#x3D; 2, name &#x3D; (null)}<br>wuwuFQ：4—&lt;_NSMainThread: 0x600002f6c400&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：4—&lt;_NSMainThread: 0x600002f6c400&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：1—&lt;NSThread: 0x600002f2c3c0&gt;{number &#x3D; 2, name &#x3D; (null)}<br>wuwuFQ：asyncSerial—End<br>wuwuFQ：2—&lt;NSThread: 0x600002f2c3c0&gt;{number &#x3D; 2, name &#x3D; (null)}<br>wuwuFQ：2—&lt;NSThread: 0x600002f2c3c0&gt;{number &#x3D; 2, name &#x3D; (null)}<br>wuwuFQ：3—&lt;NSThread: 0x600002f2c3c0&gt;{number &#x3D; 2, name &#x3D; (null)}<br>wuwuFQ：3—&lt;NSThread: 0x600002f2c3c0&gt;{number &#x3D; 2, name &#x3D; (null)}  </p>
</blockquote>
<blockquote>
<p>异步具有开启新线程的能力，但是在串行队列里面任务1、2、3只开启了一个线程，任务1、2、3在子线程按顺序执行，任务4在主线程里面，CPU在两个线程之间快速切换，所以任务4的打印会穿插在任务1、2、3中间，但任务1、2、3的执行顺序不会变。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">主队列 <span class="operator">+</span> 异步(<span class="keyword">async</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)asyncMainQueue &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;currentThread---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);  <span class="comment">// 打印当前线程</span></span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：asyncMainQueue---Begin&quot;</span>);</span><br><span class="line">    <span class="comment">//创建并行队列</span></span><br><span class="line">    dispatch_queue_t main_queue <span class="operator">=</span> dispatch_get_main_queue();</span><br><span class="line">    dispatch_async(main_queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务1</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：1---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(main_queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务2</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：2---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(main_queue, <span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">//        任务3</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; <span class="operator">++</span>i) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：3---%@&quot;</span>,[<span class="type">NSThread</span> currentThread]);      <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;wuwuFQ：asyncMainQueue---End&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>currentThread—&lt;_NSMainThread: 0x600003f740c0&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：asyncMainQueue—Begin<br>wuwuFQ：asyncMainQueue—End<br>wuwuFQ：1—&lt;_NSMainThread: 0x600003f740c0&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：1—&lt;_NSMainThread: 0x600003f740c0&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：2—&lt;_NSMainThread: 0x600003f740c0&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：2—&lt;_NSMainThread: 0x600003f740c0&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：3—&lt;_NSMainThread: 0x600003f740c0&gt;{number &#x3D; 1, name &#x3D; main}<br>wuwuFQ：3—&lt;_NSMainThread: 0x600003f740c0&gt;{number &#x3D; 1, name &#x3D; main}  </p>
</blockquote>
<blockquote>
<p>主队列不会创建新的线程，首先任务1、2、3会被插入到主队列尾部，然后任务异步执行，无需等待block回调，主线程按序执行，最后执行任务1、2、3。<br>所以结论是：主队列+异步 &#x3D; 没有开启新线程，串行执行任务</p>
</blockquote>
<h3 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h3><h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>创建线程</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">方式<span class="number">1</span></span><br><span class="line"><span class="comment">//1.创建线程</span></span><br><span class="line"><span class="comment">// 第三个参数object: 前面调用方法需要传递的参数 可以为nil</span></span><br><span class="line"><span class="type">NSThread</span> <span class="operator">*</span>thread <span class="operator">=</span> [[<span class="type">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="meta">@selector</span>(run:) object:@<span class="string">&quot;rc&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置线程的名字</span></span><br><span class="line">thread.name <span class="operator">=</span> @<span class="string">&quot;线程RC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置优先级  取值范围 0.0 ~ 1.0 之间 最高是1.0 默认优先级是0.5</span></span><br><span class="line">thread.threadPriority <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> iOS8.0之后新增  服务质量</span></span><br><span class="line"><span class="comment"> @property NSQualityOfService qualityOfService;</span></span><br><span class="line"><span class="comment"> NSQualityOfServiceUserInteractive --&gt; Main thread</span></span><br><span class="line"><span class="comment"> NSQualityOfServiceUserInitiated   --&gt; HIGH</span></span><br><span class="line"><span class="comment"> NSQualityOfServiceUtility         --&gt; LOW</span></span><br><span class="line"><span class="comment"> NSQualityOfServiceBackground      --&gt; Background</span></span><br><span class="line"><span class="comment"> NSQualityOfServiceDefault         --&gt; Default</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// thread.qualityOfService = NSQualityOfServiceDefault;    </span></span><br><span class="line"><span class="comment">//2.启动线程</span></span><br><span class="line">[thread start];</span><br><span class="line"></span><br><span class="line">方式<span class="number">2</span></span><br><span class="line">[<span class="type">NSThread</span> detachNewThreadSelector:<span class="meta">@selector</span>(run) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[<span class="type">NSThread</span> detachNewThreadWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">100</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;%i-%@&quot;</span>,i,<span class="type">NSThread</span>.currentThread.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">方式<span class="number">3</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="meta">@selector</span>(run:) withObject:@<span class="string">&quot;开启后台线程&quot;</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程的状态</p>
<ul>
<li>新建 、就绪、运行、阻塞、死亡</li>
<li>启动线程： <ul>
<li>-(void)start;</li>
</ul>
</li>
<li>阻塞（暂停）线程：进入阻塞状态<ul>
<li>+(void)sleepUntilDate:(NSDate *)date;</li>
<li>+(void)sleepForTimeInterval:(NSTimeInterval)ti;</li>
</ul>
</li>
<li>强制停止线程：进入死亡状态  <ul>
<li>+(void)exit;</li>
</ul>
</li>
</ul>
<p>线程间通信</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">NSThread</span> detachNewThreadSelector:<span class="meta">@selector</span>(download) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"><span class="operator">-</span> (void)download&#123;</span><br><span class="line">    <span class="type">NSURL</span> <span class="operator">*</span>url <span class="operator">=</span> [<span class="type">NSURL</span> <span class="type">URLWithString</span>:@<span class="string">&quot;http://00.minipic.eastday.com/20170227/20170227134901_e45455144ba23b7cee75f292229151b1_21.jpeg&quot;</span>];</span><br><span class="line">    <span class="type">NSData</span> <span class="operator">*</span>imageData <span class="operator">=</span> [<span class="type">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">    <span class="type">UIImage</span> <span class="operator">*</span>image <span class="operator">=</span> [<span class="type">UIImage</span> imageWithData:imageData];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主线程显示图片  waitUntilDone :是否等待，指的是后面代码的执行是否需要等待本次操作结束</span></span><br><span class="line">    <span class="comment">// 第一种</span></span><br><span class="line">   <span class="comment">// [self performSelector:@selector(showImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];</span></span><br><span class="line">    <span class="comment">// 第二种</span></span><br><span class="line">    [<span class="keyword">self</span>.imageView performSelectorOnMainThread:<span class="meta">@selector</span>(setImage:) withObject:image waitUntilDone:<span class="type">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 指定方法在主线程中执行</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="meta">@selector</span>(performMethod:)  <span class="comment">// 要执行的方法</span></span><br><span class="line">                       withObject:<span class="literal">nil</span>                         <span class="comment">// 执行方法时，要传入的参数 类型为 id</span></span><br><span class="line">                    waitUntilDone:<span class="type">YES</span>];                       <span class="comment">// 当前线程是否要被阻塞，直到主线程将我们指定的代码块执行完，当前线程为主线程，设置为YES时，会立即执行，为NO时加入到RunLoop中在下一次运行循环时执行</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="meta">@selector</span>(performMethod:)</span><br><span class="line">                       withObject:<span class="literal">nil</span></span><br><span class="line">                    waitUntilDone:<span class="type">YES</span></span><br><span class="line">                            modes:@[@<span class="string">&quot;kCFRunLoopDefaultMode&quot;</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定方法在某个线程中执行</span></span><br><span class="line"><span class="operator">-</span> (void)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> <span class="operator">*</span>)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait modes:(nullable <span class="type">NSArray</span>&lt;<span class="type">NSString</span> *&gt; <span class="operator">*</span>)array <span class="type">API_AVAILABLE</span>(macos(<span class="number">10.5</span>), ios(<span class="number">2.0</span>), watchos(<span class="number">2.0</span>), tvos(<span class="number">9.0</span>));</span><br><span class="line"><span class="operator">-</span> (void)performSelector:(<span class="type">SEL</span>)aSelector onThread:(<span class="type">NSThread</span> <span class="operator">*</span>)thr withObject:(nullable id)arg waitUntilDone:(<span class="type">BOOL</span>)wait;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在当前线程上执行操作，调用 NSObject 的 performSelector:相关方法</span></span><br><span class="line"><span class="operator">-</span> (id)performSelector:(<span class="type">SEL</span>)aSelector;</span><br><span class="line"><span class="operator">-</span> (id)performSelector:(<span class="type">SEL</span>)aSelector withObject:(id)object;</span><br><span class="line"><span class="operator">-</span> (id)performSelector:(<span class="type">SEL</span>)aSelector withObject:(id)object1 withObject:(id)object2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  指定方法在开启的子线程中执行 (相当于创建了一个子线程，并且执行方法)</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="meta">@selector</span>(performMethod:) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>自定义 NSThread</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">CustomThread</span> : <span class="type">NSThread</span></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">CustomThread</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)main &#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Custom thread started: %@&quot;</span>, [<span class="type">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">5</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">                <span class="type">NSLog</span>(@<span class="string">&quot;Custom thread cancelled&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;Custom thread running: %d&quot;</span>, i);</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>]; <span class="comment">// 模拟任务</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Custom thread finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line"><span class="type">CustomThread</span> <span class="operator">*</span>thread <span class="operator">=</span> [[<span class="type">CustomThread</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>

<h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><p>和GCD一样NSOperation同样有任务的概念。所谓任务就是在线程中执行的那段代码<br>NSOperation 单独使用时是同步执行操作，配合 NSOperationQueue 才能实现异步执行  </p>
<p>任务 NSOperation<br>NSOperation：抽象类，不能直接使用</p>
<ul>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义</li>
</ul>
<p>队列 NSOperationQueue<br>NSOperation 中的队列是用 NSOperationQueue 表示的，用过来存放任务的队列。</p>
<ul>
<li>不同于GCD中队列先进先出的原则，对于添加到NSOperationQueue队列中的任务，首先根据任务之间的依赖关系决定任务的就绪状态，然后进入就绪状态的任务由任务之间的相对优先级决定开始执行顺序。</li>
<li>同时NSOperationQueue提供设置最大并发任务数的途径。</li>
<li>NSOperationQueue还提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行</li>
</ul>
<p>单独使用 NSInvocationOperation&#x2F;NSBlockOperation，同步执行任务，不开启线程</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span>(void)invocationOperation&#123;</span><br><span class="line">    <span class="type">NSInvocationOperation</span> <span class="operator">*</span>operation <span class="operator">=</span> [[<span class="type">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="meta">@selector</span>(operation) object:<span class="literal">nil</span>];</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>(void)operation&#123;</span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">5</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;%d--%@&quot;</span>,i,[<span class="type">NSThread</span> currentThread]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>(void)blockOperationDemo&#123;</span><br><span class="line">    <span class="type">NSBlockOperation</span> <span class="operator">*</span>operation <span class="operator">=</span> [<span class="type">NSBlockOperation</span> blockOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">5</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>];</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;%d--%@&quot;</span>,i,[<span class="type">NSThread</span> currentThread]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [operation start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NSBlockOperation 还提供了一个方法 addExecutionBlock: 如果使用了该方法添加任务，这些任务（包括 blockOperationWithBlock 中的任务）可以在不同的线程中同时（并发）执行</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用子类 NSBlockOperation</span></span><br><span class="line"><span class="comment"> * 调用方法 AddExecutionBlock:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="operator">-</span> (void)useBlockOperationAddExecutionBlock &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建 NSBlockOperation 对象</span></span><br><span class="line">    <span class="type">NSBlockOperation</span> <span class="operator">*</span>op <span class="operator">=</span> [<span class="type">NSBlockOperation</span> blockOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;1---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.添加额外的操作</span></span><br><span class="line">    [op addExecutionBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;2---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;3---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;4---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;5---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;6---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;7---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op addExecutionBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;8---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.调用 start 方法开始执行操作</span></span><br><span class="line">    [op start];</span><br></pre></td></tr></table></figure>

<p>自定义NSOperation<br>自定义NSOperation子类有两种方式，并发和非并发。 非并发只需要继承NSOperation后，实现main方法即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">CustomOperation</span> : <span class="type">NSOperation</span></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">CustomOperation</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)main &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;CustomOperation started on thread: %@&quot;</span>, [<span class="type">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">5</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;CustomOperation cancelled&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Processing %d&quot;</span>, i);</span><br><span class="line">        [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">1</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;CustomOperation completed&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p>自定义并发的operation</p>
<ul>
<li>start：把需要执行的任务放在start方法里，任务加到队列后，队列会管理任务并在线程被调度后，调用start方法，不需要调用父类的方法</li>
<li>asynchronous：表示是否并发执行</li>
<li>executing：表示任务是否正在执行，需要手动调用KVO方法来进行通知，方便其他类监听了任务的该属性</li>
<li>finished：表示任务是否结束，需要手动调用KVO方法来进行通知，队列也需要监听改属性的值，用于判断任务是否结束</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">CustomConcurrentOperation</span> : <span class="type">NSOperation</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span> (nonatomic, assign) <span class="type">BOOL</span> executing;</span><br><span class="line"><span class="meta">@property</span> (nonatomic, assign) <span class="type">BOOL</span> finished;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">CustomConcurrentOperation</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (instancetype)<span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _executing <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">        _finished <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">BOOL</span>)isAsynchronous &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">YES</span>; <span class="comment">// 表示支持并发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">BOOL</span>)isExecuting &#123;</span><br><span class="line">    <span class="keyword">return</span> _executing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">BOOL</span>)isFinished &#123;</span><br><span class="line">    <span class="keyword">return</span> _finished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)start &#123;</span><br><span class="line">    <span class="comment">// 检查是否已取消</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">        [<span class="keyword">self</span> finish];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置任务为执行中</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:@<span class="string">&quot;isExecuting&quot;</span>];</span><br><span class="line">    _executing <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:@<span class="string">&quot;isExecuting&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在后台线程执行任务</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="meta">@selector</span>(main) withObject:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)main &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">        [<span class="keyword">self</span> finish];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Concurrent Operation started on thread: %@&quot;</span>, [<span class="type">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">5</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;Concurrent Operation cancelled&quot;</span>);</span><br><span class="line">            [<span class="keyword">self</span> finish];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Processing %d&quot;</span>, i);</span><br><span class="line">        [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;Concurrent Operation completed&quot;</span>);</span><br><span class="line">    [<span class="keyword">self</span> finish];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)finish &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:@<span class="string">&quot;isExecuting&quot;</span>];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:@<span class="string">&quot;isFinished&quot;</span>];</span><br><span class="line">    _executing <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">    _finished <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:@<span class="string">&quot;isExecuting&quot;</span>];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:@<span class="string">&quot;isFinished&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>

<p>NSOperationQueue</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 addOperation: 将操作加入到操作队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="operator">-</span> (void)addOperationToQueue &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建队列</span></span><br><span class="line">    <span class="type">NSOperationQueue</span> <span class="operator">*</span>queue <span class="operator">=</span> [[<span class="type">NSOperationQueue</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建操作</span></span><br><span class="line">    <span class="comment">// 使用 NSInvocationOperation 创建操作1</span></span><br><span class="line">    <span class="type">NSInvocationOperation</span> <span class="operator">*</span>op1 <span class="operator">=</span> [[<span class="type">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="meta">@selector</span>(task1) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 NSInvocationOperation 创建操作2</span></span><br><span class="line">    <span class="type">NSInvocationOperation</span> <span class="operator">*</span>op2 <span class="operator">=</span> [[<span class="type">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="meta">@selector</span>(task2) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 NSBlockOperation 创建操作3</span></span><br><span class="line">    <span class="type">NSBlockOperation</span> <span class="operator">*</span>op3 <span class="operator">=</span> [<span class="type">NSBlockOperation</span> blockOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;3---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [op3 addExecutionBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;4---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.使用 addOperation: 添加所有操作到队列中</span></span><br><span class="line">    [queue addOperation:op1]; <span class="comment">// [op1 start]</span></span><br><span class="line">    [queue addOperation:op2]; <span class="comment">// [op2 start]</span></span><br><span class="line">    [queue addOperation:op3]; <span class="comment">// [op3 start]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 addOperationWithBlock: 将操作加入到操作队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)addOperationWithBlockToQueue &#123;</span><br><span class="line">    <span class="comment">// 1.创建队列</span></span><br><span class="line">    <span class="type">NSOperationQueue</span> <span class="operator">*</span>queue <span class="operator">=</span> [[<span class="type">NSOperationQueue</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.使用 addOperationWithBlock: 添加操作到队列中</span></span><br><span class="line">    [queue addOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;1---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;2---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;3---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSOperationQueue 控制串行执行、并发执行<br>最大并发操作数：maxConcurrentOperationCount</p>
<ul>
<li>maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行</li>
<li>maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。</li>
<li>maxConcurrentOperationCount 大于1时，队列为并发队列</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 MaxConcurrentOperationCount（最大并发操作数）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="operator">-</span> (void)setMaxConcurrentOperationCount &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建队列</span></span><br><span class="line">    <span class="type">NSOperationQueue</span> <span class="operator">*</span>queue <span class="operator">=</span> [[<span class="type">NSOperationQueue</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置最大并发操作数</span></span><br><span class="line">    queue.maxConcurrentOperationCount <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 串行队列</span></span><br><span class="line"><span class="comment">// queue.maxConcurrentOperationCount = 2; // 并发队列</span></span><br><span class="line"><span class="comment">// queue.maxConcurrentOperationCount = 8; // 并发队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.添加操作</span></span><br><span class="line">    [queue addOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;1---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;2---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;3---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    [queue addOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;4---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<img src="/images/xiancheng_op_log_01.png" style="width: 70%;"/>

<p>NSOperation 操作依赖</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 操作依赖</span></span><br><span class="line"><span class="comment"> * 使用方法：addDependency:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="operator">-</span> (void)addDependency &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建队列</span></span><br><span class="line">    <span class="type">NSOperationQueue</span> <span class="operator">*</span>queue <span class="operator">=</span> [[<span class="type">NSOperationQueue</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建操作</span></span><br><span class="line">    <span class="type">NSBlockOperation</span> <span class="operator">*</span>op1 <span class="operator">=</span> [<span class="type">NSBlockOperation</span> blockOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;1---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="type">NSBlockOperation</span> <span class="operator">*</span>op2 <span class="operator">=</span> [<span class="type">NSBlockOperation</span> blockOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;2---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.添加依赖</span></span><br><span class="line">    [op2 addDependency:op1]; <span class="comment">// 让op2 依赖于 op1，则先执行op1，在执行op2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.添加操作到队列中</span></span><br><span class="line">    [queue addOperation:op1];</span><br><span class="line">    [queue addOperation:op2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/gcd_op_yilai_log.png/" style="width: 70%;"/>

<p>NSOperation 优先级<br>提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)setQueuePriority &#123;</span><br><span class="line">    <span class="type">NSOperationQueue</span> <span class="operator">*</span>queue <span class="operator">=</span> [[<span class="type">NSOperationQueue</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSInvocationOperation</span> <span class="operator">*</span>op <span class="operator">=</span> [[<span class="type">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="meta">@selector</span>(invocationSel:) object:@<span class="string">&quot;obj&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="type">NSBlockOperation</span> <span class="operator">*</span>blockOp <span class="operator">=</span> [<span class="type">NSBlockOperation</span> blockOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;block - %@&quot;</span>, [<span class="type">NSThread</span> currentThread]);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [op setQueuePriority:<span class="type">NSOperationQueuePriorityHigh</span>];</span><br><span class="line">    [blockOp setQueuePriority:<span class="type">NSOperationQueuePriorityLow</span>];</span><br><span class="line"></span><br><span class="line">    [op addDependency:blockOp];</span><br><span class="line">    </span><br><span class="line">    [queue addOperation:op];</span><br><span class="line">    [queue addOperation:blockOp];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>block - &lt;NSThread: 0x600000715640&gt;{number &#x3D; 3, name &#x3D; (null)}<br>obj - &lt;NSThread: 0x600000715640&gt;{number &#x3D; 3, name &#x3D; (null)}  </p>
</blockquote>
<p>NSOperation、NSOperationQueue 线程间的通信</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程间通信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="operator">-</span> (void)communication &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建队列</span></span><br><span class="line">    <span class="type">NSOperationQueue</span> <span class="operator">*</span>queue <span class="operator">=</span> [[<span class="type">NSOperationQueue</span> alloc]<span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.添加操作</span></span><br><span class="line">    [queue addOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">        <span class="comment">// 异步进行耗时操作</span></span><br><span class="line">        <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">            [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">            <span class="type">NSLog</span>(@<span class="string">&quot;1---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        [[<span class="type">NSOperationQueue</span> mainQueue] addOperationWithBlock:<span class="operator">^</span>&#123;</span><br><span class="line">            <span class="comment">// 进行一些 UI 刷新等操作</span></span><br><span class="line">            <span class="keyword">for</span> (int i <span class="operator">=</span> <span class="number">0</span>; i <span class="operator">&lt;</span> <span class="number">2</span>; i<span class="operator">++</span>) &#123;</span><br><span class="line">                [<span class="type">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; <span class="comment">// 模拟耗时操作</span></span><br><span class="line">                <span class="type">NSLog</span>(@<span class="string">&quot;2---%@&quot;</span>, [<span class="type">NSThread</span> currentThread]); <span class="comment">// 打印当前线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSOperation 常用属性和方法</p>
<ul>
<li>-(void)cancel; 可取消操作，实质是标记 isCancelled 状态。</li>
<li>-(BOOL)isFinished; 判断操作是否已经结束。</li>
<li>-(BOOL)isCancelled; 判断操作是否已经标记为取消。</li>
<li>-(BOOL)isExecuting; 判断操作是否正在在运行。</li>
<li>-(BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关</li>
<li>-(void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。</li>
<li>-(void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。</li>
<li>-(void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。</li>
<li>-(void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。<br>@property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。</li>
</ul>
<p>NSOperationQueue 常用属性和方法</p>
<ul>
<li>-(void)cancelAllOperations; 可以取消队列的所有操作。</li>
<li>-(BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。</li>
<li>-(void)setSuspended:(BOOL)b;  可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。</li>
<li>-(void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。</li>
<li>-(void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。</li>
<li>-(void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束</li>
<li>-(NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。</li>
<li>-(NSUInteger)operationCount; 当前队列中的操作数。</li>
<li>+(id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。</li>
<li>+(id)mainQueue; 获取主队列。</li>
</ul>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>主线程&#x2F;UI线程</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="comment">// Run async code on the Main/UI Thread. E.g.: Refresh TableView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后台线程（全局）</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global(qos: .background).async &#123;</span><br><span class="line">     <span class="comment">// Run async on the Background Thread. E.g.: Some API calls.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DispatchGroup</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Create Dispatch Group</span></span><br><span class="line"><span class="keyword">let</span> group <span class="operator">=</span> <span class="type">DispatchGroup</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.a. Long running Task 1</span></span><br><span class="line">group.enter()</span><br><span class="line">runLongRunningTask1(completion: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DispatchGroup: Long running Task 1 finished&quot;</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.b. Long running Task 2</span></span><br><span class="line">group.enter()</span><br><span class="line">runLongRunningTask2(completion: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DispatchGroup: Long running Task 2 finished&quot;</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.b. Long running Task 3</span></span><br><span class="line">group.enter()</span><br><span class="line">runLongRunningTask3(completion: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DispatchGroup: Long running Task 3 finished&quot;</span>)</span><br><span class="line">    group.leave()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. When all are finished Notify</span></span><br><span class="line"><span class="keyword">let</span> queueType <span class="operator">=</span> <span class="type">DispatchQueue</span>.global(qos: .userInitiated)</span><br><span class="line">group.notify(queue: queueType) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DispatchGroup - notify: All task Finished.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatchSemaphore</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">NotificationPermission</span>:<span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>(value: <span class="number">0</span>)</span><br><span class="line"><span class="comment">//获取通知权限</span></span><br><span class="line"><span class="type">UNUserNotificationCenter</span>.current().getNotificationSettings &#123; setting <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> setting.authorizationStatus <span class="operator">!=</span> .denied &#123;</span><br><span class="line">        <span class="type">NotificationPermission</span> <span class="operator">=</span> <span class="literal">true</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;====通知权限1:&quot;</span><span class="operator">+</span><span class="type">String</span>(<span class="type">NotificationPermission</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">NotificationPermission</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;====通知权限1:&quot;</span><span class="operator">+</span><span class="type">String</span>(<span class="type">NotificationPermission</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//线程恢复</span></span><br><span class="line">    semaphore.signal()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程挂起</span></span><br><span class="line">semaphore.wait()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;====通知权限2:&quot;</span><span class="operator">+</span><span class="type">String</span>(<span class="type">NotificationPermission</span>))</span><br><span class="line"><span class="comment">//task任务</span></span><br><span class="line"><span class="comment">//NotificationPermission ? print(true) : print(false)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>semaphore.wait()是减1操作，不过这个减1操作的前提是信号量是否大于0：<br>如果大于0，线程可以继续往下跑，然后紧接在semaphore.wait()这句过后，才会真正对信号量减1；<br>如果等于0，就会让线程休眠，加入到一个都等待这个信号的线程队列当中，当信号量大于0时，就会唤醒这个等待队列中靠前的线程，继续线程后面代码且对信号量减1，也就确保了信号量大于0才减1，所以不存在信号量小于0的情况</p>
<ul>
<li>semaphore.signal()是对信号量的加1操作，后来经过测试发现，通过semaphore.signal()可以任意添加信号量，所以初始化的信号量并非不可更改的，是可以随意更改的</li>
</ul>
</blockquote>
<p>Dispatch Barrier</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.<span class="keyword">init</span>(label: <span class="string">&quot;RyukieQueue&quot;</span>, qos: .default, attributes: .concurrent, autoreleaseFrequency: .workItem, target: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1: <span class="subst">\(Thread.current)</span>&quot;</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异步栅栏函数</span></span><br><span class="line">queue.async(group: <span class="literal">nil</span>, qos: .default, flags: .barrier) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;barrier - async: <span class="subst">\(Thread.current)</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">0</span><span class="operator">...</span><span class="number">100</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2: <span class="subst">\(Thread.current)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3: <span class="subst">\(Thread.current)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4: <span class="subst">\(Thread.current)</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=========: <span class="subst">\(Thread.current)</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1: &lt;NSThread: 0x6000018f1040&gt;{number &#x3D; 6, name &#x3D; (null)}<br>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;: &lt;NSThread: 0x6000018b0800&gt;{number &#x3D; 1, name &#x3D; main}<br>barrier - async: &lt;NSThread: 0x6000018f1040&gt;{number &#x3D; 6, name &#x3D; (null)}<br>…<br>…<br>…<br>4: &lt;NSThread: 0x6000018f6fc0&gt;{number &#x3D; 4, name &#x3D; (null)}<br>3: &lt;NSThread: 0x6000018f0540&gt;{number &#x3D; 5, name &#x3D; (null)}<br>2: &lt;NSThread: 0x6000018f1040&gt;{number &#x3D; 6, name &#x3D; (null)}  </p>
</blockquote>
<p>AsyncAfter</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Time</span></span><br><span class="line"><span class="keyword">let</span> delay <span class="operator">=</span> <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Schedule</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: .now() <span class="operator">+</span> delay) &#123;</span><br><span class="line">    <span class="comment">// Execute some task with delay</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DispatchWorkItem</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Task</span> <span class="operator">=</span> () <span class="operator">→</span> <span class="type">Void</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">async</span>(<span class="keyword">_</span> <span class="params">task</span>: <span class="keyword">@escaping</span> <span class="type">Task</span>) <span class="number">1</span></span><br><span class="line">    _async(task)</span><br><span class="line">｝</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">async</span>(<span class="keyword">_</span> <span class="params">task</span>: <span class="keyword">@escaping</span> <span class="type">Task</span>, <span class="params">mainTask</span>: <span class="keyword">@escaping</span> <span class="type">Task</span>) &#123;</span><br><span class="line">    _async(task, mainTask)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">_async</span>(<span class="keyword">_</span> <span class="params">task</span>: <span class="keyword">@escaping</span> <span class="type">Task</span>, <span class="params">mainTask</span>: <span class="type">Task</span>? <span class="operator">=</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> item <span class="operator">=</span> <span class="type">DispatchWorkItem</span>(block: task)</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async(execute: item)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> main <span class="operator">=</span> mainTask &#123;</span><br><span class="line">        item. notify(queue: <span class="type">DispatchQueue</span> main, execute: main)</span><br><span class="line">    ｝</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<h3 id="多读单写"><a href="#多读单写" class="headerlink" title="多读单写"></a>多读单写</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用同步 dispatch_sync ，是为了拿到 obj 结果。如果使用 dispatch_async，return 会立即执行</span></span><br><span class="line"><span class="operator">-</span> (id)objectForKey:(<span class="type">NSString</span> <span class="operator">*</span>)key &#123;</span><br><span class="line">    __block id obj;</span><br><span class="line">    <span class="comment">// 异步读取指定数据</span></span><br><span class="line">    dispatch_sync(concurrent_queue, <span class="operator">^</span>&#123;<span class="comment">// dispatch_sync 设置为同步读取</span></span><br><span class="line">        obj <span class="operator">=</span> [<span class="keyword">self</span>-&gt;userCenterDic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="operator">-</span> (void)objectForKey:(<span class="type">NSString</span> <span class="operator">*</span>)key completion:(void (<span class="operator">^</span>)(id obj))completion &#123;</span><br><span class="line">    <span class="comment">// 异步读取操作，使用并发队列</span></span><br><span class="line">    dispatch_async(concurrent_queue, <span class="operator">^</span>&#123;</span><br><span class="line">        id obj <span class="operator">=</span> [<span class="keyword">self</span>-&gt;userCenterDic objectForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)setObject:(id)obj forKey:(<span class="type">NSString</span> <span class="operator">*</span>)key &#123;</span><br><span class="line">    <span class="comment">// 异步栅栏调用设置数据</span></span><br><span class="line">    dispatch_barrier_async(concurrent_queue, <span class="operator">^</span>&#123;</span><br><span class="line">        [userCenterDic setObject:obj forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><blockquote>
<p>向当前串行队列中添加同步任务，会产生死锁</p>
</blockquote>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>NSLock  iOS 提供的最基本的互斥锁，遵循 NSLocking 协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lock <span class="operator">=</span> <span class="type">NSLock</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">threadSafeIncrement</span>() &#123;</span><br><span class="line">    lock.lock()</span><br><span class="line">    sharedResource <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    lock.unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSRecursiveLock: 递归锁允许同一个线程多次对同一个锁进行加锁，而不会造成死锁。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> recursiveLock <span class="operator">=</span> <span class="type">NSRecursiveLock</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">recursiveFunction</span>(<span class="keyword">_</span> <span class="params">count</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">    recursiveLock.lock()</span><br><span class="line">    <span class="keyword">if</span> count <span class="operator">&gt;</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Recursive count: <span class="subst">\(count)</span>&quot;</span>)</span><br><span class="line">        recursiveFunction(count <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    recursiveLock.unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">recursiveFunction(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>Synchronized  @synchronized 关键字，用于对代码块加锁。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    sharedResource <span class="operator">+=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dispatch Semaphore (GCD 信号量):信号量是一种计数型的锁，可以控制对共享资源的访问。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> semaphore <span class="operator">=</span> <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">threadSafeTask</span>() &#123;</span><br><span class="line">    semaphore.wait() <span class="comment">// 等待信号量</span></span><br><span class="line">    sharedResource <span class="operator">+=</span> <span class="number">1</span></span><br><span class="line">    semaphore.signal() <span class="comment">// 释放信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pthread_mutex: 是 POSIX 线程库中的锁，是一种较底层的锁实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutex <span class="operator">=</span> pthread_mutex_t()</span><br><span class="line">pthread_mutex_init(<span class="operator">&amp;</span>mutex, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">criticalSection</span>() &#123;</span><br><span class="line">    pthread_mutex_lock(<span class="operator">&amp;</span>mutex)</span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Critical section&quot;</span>)</span><br><span class="line">    pthread_mutex_unlock(<span class="operator">&amp;</span>mutex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904037012226061">多线程相关面试题</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/01/10/runtime-runloop/" rel="prev" title="runtime_runloop">
      <i class="fa fa-chevron-left"></i> runtime_runloop
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/01/10/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" rel="next" title="网络协议">
      网络协议 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">主线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">子线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97%E3%80%81%E4%B8%B2%E8%A1%8C%E9%98%9F%E5%88%97-%E3%80%81%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5"><span class="nav-number">5.</span> <span class="nav-text">并发队列、串行队列 、同步、异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread"><span class="nav-number">6.</span> <span class="nav-text">pthread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSThread"><span class="nav-number">7.</span> <span class="nav-text">NSThread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSOperation"><span class="nav-number">8.</span> <span class="nav-text">NSOperation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD"><span class="nav-number">9.</span> <span class="nav-text">GCD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%AF%BB%E5%8D%95%E5%86%99"><span class="nav-number">10.</span> <span class="nav-text">多读单写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">11.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">12.</span> <span class="nav-text">锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">13.</span> <span class="nav-text">参考文章</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">刘宏亮</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘宏亮</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
